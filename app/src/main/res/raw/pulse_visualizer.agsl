// This is the input texture/bitmap that will be deformed.
// It's typically the content of the Composable the shader is applied to.
uniform shader inputShader;

// The resolution (width, height) of the area where the shader is applied, in pixels.
// Used for accurate coordinate calculations.
uniform float2 uResolution;

// The current animation time, in seconds. This value advances each frame,
// driving the wave's propagation and damping.
uniform float uTime;

// Maximum number of active pulses (waves) the shader can process simultaneously.
// This must match the size of the uniform arrays passed from Kotlin.
const int MAX_PULSES = 20;

// The actual number of active pulses currently being processed (<= MAX_PULSES).
uniform int uNumWaves; // Renamed to uNumWaves for consistency with ViewModel's 'Wave' object

// Arrays holding the parameters for each active pulse (wave).
// These are populated by the Kotlin code.
uniform float2 uWaveOrigins[MAX_PULSES];       // (x, y) coordinates of the pulse's origin.
uniform float uWaveAmplitudes[MAX_PULSES];    // Initial amplitude (intensity) of the pulse.
uniform float uWaveFrequencies[MAX_PULSES];   // Frequency of the wave within the pulse (how many cycles per unit distance).
uniform float uWaveSpeeds[MAX_PULSES];        // Propagation speed of the pulse (pixels per second).
uniform float uWaveStartTimes[MAX_PULSES];    // Time (in seconds) when the pulse was initiated.

// Global damping factor applied to all pulses.
// Controls how quickly pulse amplitude diminishes over time.
uniform float uGlobalDamping;

// Minimum amplitude threshold. Pulses whose calculated amplitude falls below this
// value will have no effect on the pixels, improving performance.
uniform float uMinAmplitudeThreshold;

// Define PI for mathematical calculations.
float PI = 3.141592653589793;

/**
 * The main entry point for the fragment shader. This function is executed for every pixel
 * on the screen (or the target drawing surface).
 *
 * @param fragCoord The absolute (x, y) coordinate of the current pixel being processed, in pixels.
 * @return The final color for the current pixel, typically sampled from the inputShader
 * after applying the calculated deformation.
 */
half4 main(float2 fragCoord) {
    // 'fragCoord' represents the current pixel's position
    float2 point = fragCoord;

    // Initialize the total offset for the current pixel to zero.
    // This will accumulate the deformation effect from all active pulses.
    float2 totalOffset = float2(0.0, 0.0);

    // Iterate through all active pulses (up to MAX_PULSES).
    for (int i = 0; i < MAX_PULSES; i++) {
        if (i >= uNumWaves) continue; // Using uNumWaves for actual active count

        // Retrieve parameters for the current pulse from the uniform arrays.
        float pulseStartTime = uWaveStartTimes[i];
        float pulseAmplitude = uWaveAmplitudes[i];
        float pulseFrequency = uWaveFrequencies[i];
        float pulseSpeed = uWaveSpeeds[i];
        float2 pulseOrigin = uWaveOrigins[i];

        // Calculate the elapsed time for this specific pulse since its creation.
        float elapsed = uTime - pulseStartTime;

        // Calculate the vector from the pulse's origin to the current pixel,
        // and then its magnitude (distance).
        float2 diff = point - pulseOrigin;
        float distance = length(diff);

        // Calculate how far the pulse wave front has propagated.
        float waveFront = pulseSpeed * elapsed;

        // Calculate the relative distance from the wave front.
        // If relDist > 0, the pulse wave hasn't reached this pixel yet.
        float relDist = distance - waveFront;

        // Optimization: If the pulse hasn't reached this pixel, skip to the next pulse.
        if (relDist > 0.0) {
            continue;
        }

        // Calculate angular frequency (omega) and wave number (k).
        float omega = pulseFrequency * 2.0 * PI;
        float k = omega / pulseSpeed;

        // Calculate the current amplitude of the pulse, considering damping over time.
        // `pow(base, exponent)` is used for exponential damping.
        float currentAmplitude = pulseAmplitude * pow(uGlobalDamping, elapsed);

        // Optimization: If the current amplitude is too low, its effect is negligible.
        // Skip this pulse for the current pixel.
        if (currentAmplitude < uMinAmplitudeThreshold) {
            continue;
        }

        // Calculate the phase of the pulse wave at this pixel and time.
        float phase = k * distance - omega * elapsed;

        // Calculate the actual displacement magnitude (pulse effect) at this pixel.
        // `sin` function creates the ripple peaks and troughs.
        float pulseEffect = sin(phase) * currentAmplitude;

        // Determine the direction of the deformation.
        // It's a normalized vector pointing from the pulse origin to the current pixel.
        float2 direction = float2(0.0, 0.0);
        if (distance > 0.0) {
            direction = diff / distance; // Normalize the difference vector
        }

        // Accumulate the deformation offset from this pulse to the total.
        totalOffset += direction * pulseEffect;
    }

    // Finally, sample the `inputShader` (the bitmap) at the deformed coordinates.
    // `fragCoord + totalOffset` gives the new, shifted position to fetch the color from.
    return inputShader.eval(fragCoord + totalOffset);
}